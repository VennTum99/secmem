---
layout: post
title:  "Stack 자료구조와 실습"
date:   2021-05-18 08:00:00
author: VennTum
tags: [data-structure, algorithm]
---

# Stack

## Stack이란
스택 자료구조란 항상 한쪽 방향에서만 자료의 입력 및 출력이 가능한 형태의 선형 자료구조입니다.
책상 위에 책을 무더기로 쌓아놓은 상태를 생각하면 스택 구조를 이해하기 쉽습니다. 여러 개의 책이 쌓인 상태에서, 우리는 가장 위에 놓여져 있는 책만 쉽게 들어올릴 수 있으며, 가장 위에만 새롭게 책을 놓는 것이 쉽습니다. 물론 중간에 있는 위치에 책을 넣거나 빼는 것도 가능하지만, 이를 위해서는 그보다 위에 있는 책들을 들어야 하죠.
여기서 가장 위에 있는 책이라는 의미는, 책들이 쌓이기 시작했을 때 가장 마지막에 쌓인 책이라는 뜻이 됩니다.

스택도 마찬가지로 선형구조에서, 존재하는 자료들 중 가장 마지막에 들어온 자료만을 접근하거나, 혹은 그 위치 바로 뒤에 자료를 추가하는 것이 가능합니다.
이처럼 마지막 위치에서 입,출력이 일어나는 구조를 LIFO(Last-In-First-Out) 라고 부릅니다. 마지막으로 들어온 자료가 처음으로 나가게 되며, 처음으로 들어온 자료가 나머지 모든 자료가 나간 후에야 마지막으로 나가게 되기 때문입니다.

## 구현

![Stack 자료구조](/assets/images/VennTum/stack/stack_1.png)

스택 자료구조에서 가장 중요한 역할을 하는 것은 바로 'top' 입니다. top은 스택 내 가장 마지막 원소를 가리키고 있으며, stack의 거의 모든 연산은 top을 이용해서 해결하는 것이 가능합니다.

스택에서 지원하는 연산들은 다음과 같습니다.

- Stack.top() = 스택 내 가장 마지막에 들어온 원소를 반환합니다. top이 가리키는 원소를 반환합니다.
- Stack.push(a) = 스택의 마지막 위치 뒤에 새로운 a 자료를 추가합니다. 이 경우, top이 가리키는 위치가 1단계 증가하게 됩니다.
- Stack.pop() - 스택의 가장 마지막 위치에 있는 원소를 제거합니다. top이 가리키는 원소를 제거한 후, top의 위치가 1단계 감소하게 됩니다.
- Stack.size() - 스택 내 원소의 수를 반환합니다. 구현에 따라 다르나, 스택 내 첫 원소의 위치를 1이라 했을 때, top이 가리키고 있는 단계가 size가 됩니다.
- Stack.empty() - 스택이 비어있는지 여부를 반환합니다. top이 0단계를 가리키고 있을 경우 참을, 그렇지 않을 경우 거짓을 반환합니다.

이외에도 다른 연산들을 추가할 수 있으며, 이는 스택을 구현할 때 사용하는 자료구조에 따라서도 달라질 수 있습니다.

스택을 구현하는 자료구조는 크게 2가지가 있습니다.

- 배열
- 연결 리스트

배열을 사용해서 구현할 경우, 임의 접근(random access)이 가능해집니다. 우리가 top의 위치를 가지고 연산을 하는 것 뿐만 아니라, 스택 내부에 있는 원소들도 배열의 인덱싱을 통한 접근이 가능해집니다. 이 경우 삽입과 삭제를 구현하기 보다는, 중간에 있는 값을 확인하여 사용하거나 값을 변경하는데에 의의가 조금 더 큽니다.

허나 스택을 사용해야하는 경우에는, 중간에 있는 값을 접근하는 것에 큰 의미가 없는 경우가 많습니다. 그러한 이유로, 연결 리스트를 이용해서 스택을 구현하는 것과 큰 차이가 없게 됩니다.

## 사용하는 경우

### 재귀함수

스택 자료구조 자체를 처음 들어보더라도, 이미 스택의 아이디어를 사용하여 동작하고 있는 것 중 우리가 알고 있는 내용이 있습니다.

바로 함수에서 또 다른 함수를 호출하는 경우들이 그러하며, 그 중 가장 유명한 것으로 자기자신을 호출하는 '재귀함수'가 있습니다. (C언어를 기준으로 설명하겠습니다)

A함수에서 B함수를 호출했다고 합니다. 이 경우, 우리는 A 함수를 동작하고 있다가도, B함수를 호출하는 부분에서 멈춘 후, B함수를 동작하게 됩니다.
이 과정에서, 현재까지 동작한 A함수의 상태를 저장하고 있지 않다면, B함수를 동작한 이후 다시 A함수로 돌아와도, 어떤 부분에서부터 코드 동작을 이어나갈지에 대한 정보를 알 수가 업습니다.

이를 해결하기 위해서, 함수는 자신이 호출 될 때에 그 함수의 상태를 스택을 통해서 관리해줍니다.

A함수가 호출될 때에 스택에 A함수의 현재 상태를 저장하면서 진행해 나갑니다. 그러다가 B함수가 호출될 경우, 스택에 A함수의 현재 상태까지 저장해놓은 후 중단하고, B함수의 시작 상태를 스택에 새롭게 추가하게 됩니다. 이 경우, 항상 현재 동작하는 부분은 스택에 가장 마지막에 들어온 함수가 동작합니다. 이후 B함수의 동작이 모두 끝나게 되면 스택에서 B함수를 제거하게 되고, 다시 스택의 가장 마지막 자료를 확인하게 됩니다. 이 때, 스택에는 A함수가 남아있으며, 중단한 위치는 B함수를 호출하는 구문에서 중단되었다는 정보를 스택 자료를 통해 알아 낼 수 있게 됩니다. 이를 사용하여 A함수를 다시 동작할 때, 처음부터 동작하는 것이 아닌 B함수를 호출한 이후의 위치부터 동작하는 것이 가능해집니다.

이와 같은 구조는 함수를 호출할 때마다 함수 상태를 스택에 저장하는 것으로 구현됩니다.

이 때문에 발생하는 문제 중, 한 번씩 겪어보았을 문제가 있습니다.

stackoverflow on function call

바로 함수를 관리하는 스택이 초과하여 overflow가 나는 경우입니다. 함수를 관리하는 Stack도 결국 메모리를 사용하기 때문에, 최대치 이상의 함수 호출이 스택을 통해 관리된다면 메모리가 부족하게 되어 stackoverflow가 발생하게 됩니다. 보통 C언어의 경우 몇십만 회 이상의 함수 호출이 쌓여있는 경우 발생하게 되며, 이는 설정을 통해 function call에 메모리를 추가로 할당하거나, 혹은 재귀함수를 자신이 직접 stack을 통해 구현하여 해결하는 방법 등이 있습니다.

### 알고리즘 문제 해결

스택을 알고리즘 문제 해결에서 사용하는 경우, 굉장히 많은 스택의 사용법은 다음 조건을 만족시키기 위해 사용됩니다.

- 스택 내부가 특별한 정렬 순서로 유지되어야 할 경우

스택을 사용하는 문제 중 위 조건을 만족해야하는 문제의 경우, 실제 문제를 해결하는 과정을 보면서 설명하도록 하겠습니다.

# 스택을 사용하는 문제

## 


# 코드

## Disjoint Set - Union & find

``` C
int parent[n + 1] = {0, 1, ..., n};

int find(int a){
 if(a == parent[a]) return a;
 return find(parent[a]);
}
void union(int a, int b){
 a = find(a);
 b = find(b);
 parent[b] = a;
}
```

## path compression

``` C
int find(int a){
 if(a == parent[a]) return a;
 return parent[a] = find(parent[a]);
}
```

## rank compression(by using size)

``` C
int rank[n + 1] = {1, 1, ..., 1};

void union(int a, int b){
 a = find(a);
 b = find(b);
 if(rank[a] < rank[b]) swap(a, b);
 rank[a] += rank[b];
 parent[b] = a;
}
```

현재 c++ 버전에 따라 rank를 변수명으로 사용할 수 없을 수도 있으니, 이를 고려하여 변수명을 바꾸어 사용하시면 됩니다.
